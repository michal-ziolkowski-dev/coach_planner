// ignore_for_file: non_constant_identifier_names, camel_case_types, file_namesimport, file_names, unnecessary_null_comparison,prefer_null_aware_operators

// WARNING: This code is auto-generated by Supadart.
// WARNING: Modifications may be overwritten. Please make changes in the SupaDart configuration.

// No geobase needed
// No Intl package needed
// No Dart Convert needed
// Supadart Class
abstract class SupadartClass<T> {
  static Map<String, dynamic> insert(Map<String, dynamic> data) {
    throw UnimplementedError();
  }

  static Map<String, dynamic> update(Map<String, dynamic> data) {
    throw UnimplementedError();
  }

  factory SupadartClass.fromJson(Map<String, dynamic> json) {
    throw UnimplementedError();
  }

  static converter(List<Map<String, dynamic>> data) {
    throw UnimplementedError();
  }

  static converterSingle(Map<String, dynamic> data) {
    throw UnimplementedError();
  }
}

// Enums
enum USER_ROLE { admin, trainer, athlete }

enum BOOKING_STATUS { reserved, cancelled, completed }

enum LOG_ENTITY_TYPE { user, slot, booking }

enum LOG_ACTION_TYPE { create, update, delete, status_auto_update }

// Utils
class TrainerDirectory implements SupadartClass<TrainerDirectory> {
  final String trainerId;
  final String displayName;
  final String? contactEmail;
  final String? contactPhone;
  final DateTime updatedAt;

  const TrainerDirectory({
    required this.trainerId,
    required this.displayName,
    this.contactEmail,
    this.contactPhone,
    required this.updatedAt,
  });

  static String get table_name => 'trainer_directory';
  static String get c_trainerId => 'trainer_id';
  static String get c_displayName => 'display_name';
  static String get c_contactEmail => 'contact_email';
  static String get c_contactPhone => 'contact_phone';
  static String get c_updatedAt => 'updated_at';

  static List<TrainerDirectory> converter(List<Map<String, dynamic>> data) {
    return data.map(TrainerDirectory.fromJson).toList();
  }

  static TrainerDirectory converterSingle(Map<String, dynamic> data) {
    return TrainerDirectory.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? trainerId,
    String? displayName,
    String? contactEmail,
    String? contactPhone,
    DateTime? updatedAt,
  }) {
    return {
      if (trainerId != null) 'trainer_id': trainerId,
      if (displayName != null) 'display_name': displayName,
      if (contactEmail != null) 'contact_email': contactEmail,
      if (contactPhone != null) 'contact_phone': contactPhone,
      if (updatedAt != null) 'updated_at': updatedAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? trainerId,
    required String displayName,
    String? contactEmail,
    String? contactPhone,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      trainerId: trainerId,
      displayName: displayName,
      contactEmail: contactEmail,
      contactPhone: contactPhone,
      updatedAt: updatedAt,
    );
  }

  static Map<String, dynamic> update({
    String? trainerId,
    String? displayName,
    String? contactEmail,
    String? contactPhone,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      trainerId: trainerId,
      displayName: displayName,
      contactEmail: contactEmail,
      contactPhone: contactPhone,
      updatedAt: updatedAt,
    );
  }

  factory TrainerDirectory.fromJson(Map<String, dynamic> jsonn) {
    return TrainerDirectory(
      trainerId: jsonn['trainer_id'] != null
          ? jsonn['trainer_id'].toString()
          : '',
      displayName: jsonn['display_name'] != null
          ? jsonn['display_name'].toString()
          : '',
      contactEmail: jsonn['contact_email'] != null
          ? jsonn['contact_email'].toString()
          : null,
      contactPhone: jsonn['contact_phone'] != null
          ? jsonn['contact_phone'].toString()
          : null,
      updatedAt: jsonn['updated_at'] != null
          ? DateTime.parse(jsonn['updated_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      trainerId: trainerId,
      displayName: displayName,
      contactEmail: contactEmail,
      contactPhone: contactPhone,
      updatedAt: updatedAt,
    );
  }
}

class Slots implements SupadartClass<Slots> {
  final String id;
  final String trainerId;
  final DateTime startAt;
  final DateTime endAt;
  final int durationMinutes;
  final int capacity;
  final String? notes;
  final DateTime? cancelledAt;
  final DateTime createdAt;
  final DateTime updatedAt;

  const Slots({
    required this.id,
    required this.trainerId,
    required this.startAt,
    required this.endAt,
    required this.durationMinutes,
    required this.capacity,
    this.notes,
    this.cancelledAt,
    required this.createdAt,
    required this.updatedAt,
  });

  static String get table_name => 'slots';
  static String get c_id => 'id';
  static String get c_trainerId => 'trainer_id';
  static String get c_startAt => 'start_at';
  static String get c_endAt => 'end_at';
  static String get c_durationMinutes => 'duration_minutes';
  static String get c_capacity => 'capacity';
  static String get c_notes => 'notes';
  static String get c_cancelledAt => 'cancelled_at';
  static String get c_createdAt => 'created_at';
  static String get c_updatedAt => 'updated_at';

  static List<Slots> converter(List<Map<String, dynamic>> data) {
    return data.map(Slots.fromJson).toList();
  }

  static Slots converterSingle(Map<String, dynamic> data) {
    return Slots.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? trainerId,
    DateTime? startAt,
    DateTime? endAt,
    int? durationMinutes,
    int? capacity,
    String? notes,
    DateTime? cancelledAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (trainerId != null) 'trainer_id': trainerId,
      if (startAt != null) 'start_at': startAt.toUtc().toIso8601String(),
      if (endAt != null) 'end_at': endAt.toUtc().toIso8601String(),
      if (durationMinutes != null) 'duration_minutes': durationMinutes,
      if (capacity != null) 'capacity': capacity,
      if (notes != null) 'notes': notes,
      if (cancelledAt != null)
        'cancelled_at': cancelledAt.toUtc().toIso8601String(),
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (updatedAt != null) 'updated_at': updatedAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String trainerId,
    required DateTime startAt,
    required DateTime endAt,
    int? durationMinutes,
    int? capacity,
    String? notes,
    DateTime? cancelledAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      trainerId: trainerId,
      startAt: startAt,
      endAt: endAt,
      durationMinutes: durationMinutes,
      capacity: capacity,
      notes: notes,
      cancelledAt: cancelledAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    String? trainerId,
    DateTime? startAt,
    DateTime? endAt,
    int? durationMinutes,
    int? capacity,
    String? notes,
    DateTime? cancelledAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      trainerId: trainerId,
      startAt: startAt,
      endAt: endAt,
      durationMinutes: durationMinutes,
      capacity: capacity,
      notes: notes,
      cancelledAt: cancelledAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  factory Slots.fromJson(Map<String, dynamic> jsonn) {
    return Slots(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      trainerId: jsonn['trainer_id'] != null
          ? jsonn['trainer_id'].toString()
          : '',
      startAt: jsonn['start_at'] != null
          ? DateTime.parse(jsonn['start_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      endAt: jsonn['end_at'] != null
          ? DateTime.parse(jsonn['end_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      durationMinutes: jsonn['duration_minutes'] != null
          ? int.parse(jsonn['duration_minutes'].toString())
          : 0,
      capacity: jsonn['capacity'] != null
          ? int.parse(jsonn['capacity'].toString())
          : 0,
      notes: jsonn['notes'] != null ? jsonn['notes'].toString() : null,
      cancelledAt: jsonn['cancelled_at'] != null
          ? DateTime.parse(jsonn['cancelled_at'].toString())
          : null,
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      updatedAt: jsonn['updated_at'] != null
          ? DateTime.parse(jsonn['updated_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      trainerId: trainerId,
      startAt: startAt,
      endAt: endAt,
      durationMinutes: durationMinutes,
      capacity: capacity,
      notes: notes,
      cancelledAt: cancelledAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}

class Bookings implements SupadartClass<Bookings> {
  final String id;
  final String slotId;
  final String userId;
  final BOOKING_STATUS status;
  final DateTime statusChangedAt;
  final bool autoProcessed;
  final DateTime createdAt;
  final DateTime updatedAt;

  const Bookings({
    required this.id,
    required this.slotId,
    required this.userId,
    required this.status,
    required this.statusChangedAt,
    required this.autoProcessed,
    required this.createdAt,
    required this.updatedAt,
  });

  static String get table_name => 'bookings';
  static String get c_id => 'id';
  static String get c_slotId => 'slot_id';
  static String get c_userId => 'user_id';
  static String get c_status => 'status';
  static String get c_statusChangedAt => 'status_changed_at';
  static String get c_autoProcessed => 'auto_processed';
  static String get c_createdAt => 'created_at';
  static String get c_updatedAt => 'updated_at';

  static List<Bookings> converter(List<Map<String, dynamic>> data) {
    return data.map(Bookings.fromJson).toList();
  }

  static Bookings converterSingle(Map<String, dynamic> data) {
    return Bookings.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? slotId,
    String? userId,
    BOOKING_STATUS? status,
    DateTime? statusChangedAt,
    bool? autoProcessed,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (slotId != null) 'slot_id': slotId,
      if (userId != null) 'user_id': userId,
      if (status != null) 'status': status.toString().split('.').last,
      if (statusChangedAt != null)
        'status_changed_at': statusChangedAt.toUtc().toIso8601String(),
      if (autoProcessed != null) 'auto_processed': autoProcessed,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (updatedAt != null) 'updated_at': updatedAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String slotId,
    required String userId,
    BOOKING_STATUS? status,
    DateTime? statusChangedAt,
    bool? autoProcessed,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      slotId: slotId,
      userId: userId,
      status: status,
      statusChangedAt: statusChangedAt,
      autoProcessed: autoProcessed,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    String? slotId,
    String? userId,
    BOOKING_STATUS? status,
    DateTime? statusChangedAt,
    bool? autoProcessed,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      slotId: slotId,
      userId: userId,
      status: status,
      statusChangedAt: statusChangedAt,
      autoProcessed: autoProcessed,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  factory Bookings.fromJson(Map<String, dynamic> jsonn) {
    return Bookings(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      slotId: jsonn['slot_id'] != null ? jsonn['slot_id'].toString() : '',
      userId: jsonn['user_id'] != null ? jsonn['user_id'].toString() : '',
      status: jsonn['status'] != null
          ? BOOKING_STATUS.values.byName(jsonn['status'].toString())
          : BOOKING_STATUS.values.first,
      statusChangedAt: jsonn['status_changed_at'] != null
          ? DateTime.parse(jsonn['status_changed_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      autoProcessed: jsonn['auto_processed'] != null
          ? jsonn['auto_processed'] as bool
          : false,
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      updatedAt: jsonn['updated_at'] != null
          ? DateTime.parse(jsonn['updated_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      slotId: slotId,
      userId: userId,
      status: status,
      statusChangedAt: statusChangedAt,
      autoProcessed: autoProcessed,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}

class ActivityLogs implements SupadartClass<ActivityLogs> {
  final String id;
  final LOG_ENTITY_TYPE entityType;
  final String entityId;
  final LOG_ACTION_TYPE action;
  final String? changedBy;
  final USER_ROLE? changedByRole;
  final Map<String, dynamic> changedFields;
  final Map<String, dynamic> metadata;
  final DateTime createdAt;

  const ActivityLogs({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.action,
    this.changedBy,
    this.changedByRole,
    required this.changedFields,
    required this.metadata,
    required this.createdAt,
  });

  static String get table_name => 'activity_logs';
  static String get c_id => 'id';
  static String get c_entityType => 'entity_type';
  static String get c_entityId => 'entity_id';
  static String get c_action => 'action';
  static String get c_changedBy => 'changed_by';
  static String get c_changedByRole => 'changed_by_role';
  static String get c_changedFields => 'changed_fields';
  static String get c_metadata => 'metadata';
  static String get c_createdAt => 'created_at';

  static List<ActivityLogs> converter(List<Map<String, dynamic>> data) {
    return data.map(ActivityLogs.fromJson).toList();
  }

  static ActivityLogs converterSingle(Map<String, dynamic> data) {
    return ActivityLogs.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    LOG_ENTITY_TYPE? entityType,
    String? entityId,
    LOG_ACTION_TYPE? action,
    String? changedBy,
    USER_ROLE? changedByRole,
    Map<String, dynamic>? changedFields,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (entityType != null)
        'entity_type': entityType.toString().split('.').last,
      if (entityId != null) 'entity_id': entityId,
      if (action != null) 'action': action.toString().split('.').last,
      if (changedBy != null) 'changed_by': changedBy,
      if (changedByRole != null)
        'changed_by_role': changedByRole.toString().split('.').last,
      if (changedFields != null) 'changed_fields': changedFields,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required LOG_ENTITY_TYPE entityType,
    required String entityId,
    required LOG_ACTION_TYPE action,
    String? changedBy,
    USER_ROLE? changedByRole,
    required Map<String, dynamic> changedFields,
    required Map<String, dynamic> metadata,
    DateTime? createdAt,
  }) {
    return _generateMap(
      id: id,
      entityType: entityType,
      entityId: entityId,
      action: action,
      changedBy: changedBy,
      changedByRole: changedByRole,
      changedFields: changedFields,
      metadata: metadata,
      createdAt: createdAt,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    LOG_ENTITY_TYPE? entityType,
    String? entityId,
    LOG_ACTION_TYPE? action,
    String? changedBy,
    USER_ROLE? changedByRole,
    Map<String, dynamic>? changedFields,
    Map<String, dynamic>? metadata,
    DateTime? createdAt,
  }) {
    return _generateMap(
      id: id,
      entityType: entityType,
      entityId: entityId,
      action: action,
      changedBy: changedBy,
      changedByRole: changedByRole,
      changedFields: changedFields,
      metadata: metadata,
      createdAt: createdAt,
    );
  }

  factory ActivityLogs.fromJson(Map<String, dynamic> jsonn) {
    return ActivityLogs(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      entityType: jsonn['entity_type'] != null
          ? LOG_ENTITY_TYPE.values.byName(jsonn['entity_type'].toString())
          : LOG_ENTITY_TYPE.values.first,
      entityId: jsonn['entity_id'] != null ? jsonn['entity_id'].toString() : '',
      action: jsonn['action'] != null
          ? LOG_ACTION_TYPE.values.byName(jsonn['action'].toString())
          : LOG_ACTION_TYPE.values.first,
      changedBy: jsonn['changed_by'] != null
          ? jsonn['changed_by'].toString()
          : null,
      changedByRole: jsonn['changed_by_role'] != null
          ? USER_ROLE.values.byName(jsonn['changed_by_role'].toString())
          : USER_ROLE.values.first,
      changedFields: jsonn['changed_fields'] != null
          ? jsonn['changed_fields'] as Map<String, dynamic>
          : <String, dynamic>{},
      metadata: jsonn['metadata'] != null
          ? jsonn['metadata'] as Map<String, dynamic>
          : <String, dynamic>{},
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      entityType: entityType,
      entityId: entityId,
      action: action,
      changedBy: changedBy,
      changedByRole: changedByRole,
      changedFields: changedFields,
      metadata: metadata,
      createdAt: createdAt,
    );
  }
}

class BookingStatusHistory implements SupadartClass<BookingStatusHistory> {
  final BigInt id;
  final String bookingId;
  final BOOKING_STATUS previousStatus;
  final BOOKING_STATUS currentStatus;
  final DateTime changedAt;
  final String? changedBy;
  final bool autoProcessed;

  const BookingStatusHistory({
    required this.id,
    required this.bookingId,
    required this.previousStatus,
    required this.currentStatus,
    required this.changedAt,
    this.changedBy,
    required this.autoProcessed,
  });

  static String get table_name => 'booking_status_history';
  static String get c_id => 'id';
  static String get c_bookingId => 'booking_id';
  static String get c_previousStatus => 'previous_status';
  static String get c_currentStatus => 'current_status';
  static String get c_changedAt => 'changed_at';
  static String get c_changedBy => 'changed_by';
  static String get c_autoProcessed => 'auto_processed';

  static List<BookingStatusHistory> converter(List<Map<String, dynamic>> data) {
    return data.map(BookingStatusHistory.fromJson).toList();
  }

  static BookingStatusHistory converterSingle(Map<String, dynamic> data) {
    return BookingStatusHistory.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    BigInt? id,
    String? bookingId,
    BOOKING_STATUS? previousStatus,
    BOOKING_STATUS? currentStatus,
    DateTime? changedAt,
    String? changedBy,
    bool? autoProcessed,
  }) {
    return {
      if (id != null) 'id': id.toString(),
      if (bookingId != null) 'booking_id': bookingId,
      if (previousStatus != null)
        'previous_status': previousStatus.toString().split('.').last,
      if (currentStatus != null)
        'current_status': currentStatus.toString().split('.').last,
      if (changedAt != null) 'changed_at': changedAt.toUtc().toIso8601String(),
      if (changedBy != null) 'changed_by': changedBy,
      if (autoProcessed != null) 'auto_processed': autoProcessed,
    };
  }

  static Map<String, dynamic> insert({
    BigInt? id,
    required String bookingId,
    required BOOKING_STATUS previousStatus,
    required BOOKING_STATUS currentStatus,
    DateTime? changedAt,
    String? changedBy,
    bool? autoProcessed,
  }) {
    return _generateMap(
      id: id,
      bookingId: bookingId,
      previousStatus: previousStatus,
      currentStatus: currentStatus,
      changedAt: changedAt,
      changedBy: changedBy,
      autoProcessed: autoProcessed,
    );
  }

  static Map<String, dynamic> update({
    BigInt? id,
    String? bookingId,
    BOOKING_STATUS? previousStatus,
    BOOKING_STATUS? currentStatus,
    DateTime? changedAt,
    String? changedBy,
    bool? autoProcessed,
  }) {
    return _generateMap(
      id: id,
      bookingId: bookingId,
      previousStatus: previousStatus,
      currentStatus: currentStatus,
      changedAt: changedAt,
      changedBy: changedBy,
      autoProcessed: autoProcessed,
    );
  }

  factory BookingStatusHistory.fromJson(Map<String, dynamic> jsonn) {
    return BookingStatusHistory(
      id: jsonn['id'] != null
          ? BigInt.parse(jsonn['id'].toString())
          : BigInt.from(0),
      bookingId: jsonn['booking_id'] != null
          ? jsonn['booking_id'].toString()
          : '',
      previousStatus: jsonn['previous_status'] != null
          ? BOOKING_STATUS.values.byName(jsonn['previous_status'].toString())
          : BOOKING_STATUS.values.first,
      currentStatus: jsonn['current_status'] != null
          ? BOOKING_STATUS.values.byName(jsonn['current_status'].toString())
          : BOOKING_STATUS.values.first,
      changedAt: jsonn['changed_at'] != null
          ? DateTime.parse(jsonn['changed_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      changedBy: jsonn['changed_by'] != null
          ? jsonn['changed_by'].toString()
          : null,
      autoProcessed: jsonn['auto_processed'] != null
          ? jsonn['auto_processed'] as bool
          : false,
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      bookingId: bookingId,
      previousStatus: previousStatus,
      currentStatus: currentStatus,
      changedAt: changedAt,
      changedBy: changedBy,
      autoProcessed: autoProcessed,
    );
  }
}

class Users implements SupadartClass<Users> {
  final String id;
  final String email;
  final String passwordHash;
  final String firstName;
  final String? lastName;
  final USER_ROLE role;
  final String? contactEmail;
  final String? contactPhone;
  final Map<String, dynamic> preferences;
  final bool isAnonymous;
  final DateTime? deletedAt;
  final DateTime createdAt;
  final DateTime updatedAt;

  const Users({
    required this.id,
    required this.email,
    required this.passwordHash,
    required this.firstName,
    this.lastName,
    required this.role,
    this.contactEmail,
    this.contactPhone,
    required this.preferences,
    required this.isAnonymous,
    this.deletedAt,
    required this.createdAt,
    required this.updatedAt,
  });

  static String get table_name => 'users';
  static String get c_id => 'id';
  static String get c_email => 'email';
  static String get c_passwordHash => 'password_hash';
  static String get c_firstName => 'first_name';
  static String get c_lastName => 'last_name';
  static String get c_role => 'role';
  static String get c_contactEmail => 'contact_email';
  static String get c_contactPhone => 'contact_phone';
  static String get c_preferences => 'preferences';
  static String get c_isAnonymous => 'is_anonymous';
  static String get c_deletedAt => 'deleted_at';
  static String get c_createdAt => 'created_at';
  static String get c_updatedAt => 'updated_at';

  static List<Users> converter(List<Map<String, dynamic>> data) {
    return data.map(Users.fromJson).toList();
  }

  static Users converterSingle(Map<String, dynamic> data) {
    return Users.fromJson(data);
  }

  static Map<String, dynamic> _generateMap({
    String? id,
    String? email,
    String? passwordHash,
    String? firstName,
    String? lastName,
    USER_ROLE? role,
    String? contactEmail,
    String? contactPhone,
    Map<String, dynamic>? preferences,
    bool? isAnonymous,
    DateTime? deletedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return {
      if (id != null) 'id': id,
      if (email != null) 'email': email,
      if (passwordHash != null) 'password_hash': passwordHash,
      if (firstName != null) 'first_name': firstName,
      if (lastName != null) 'last_name': lastName,
      if (role != null) 'role': role.toString().split('.').last,
      if (contactEmail != null) 'contact_email': contactEmail,
      if (contactPhone != null) 'contact_phone': contactPhone,
      if (preferences != null) 'preferences': preferences,
      if (isAnonymous != null) 'is_anonymous': isAnonymous,
      if (deletedAt != null) 'deleted_at': deletedAt.toUtc().toIso8601String(),
      if (createdAt != null) 'created_at': createdAt.toUtc().toIso8601String(),
      if (updatedAt != null) 'updated_at': updatedAt.toUtc().toIso8601String(),
    };
  }

  static Map<String, dynamic> insert({
    String? id,
    required String email,
    required String passwordHash,
    required String firstName,
    String? lastName,
    USER_ROLE? role,
    String? contactEmail,
    String? contactPhone,
    required Map<String, dynamic> preferences,
    bool? isAnonymous,
    DateTime? deletedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      email: email,
      passwordHash: passwordHash,
      firstName: firstName,
      lastName: lastName,
      role: role,
      contactEmail: contactEmail,
      contactPhone: contactPhone,
      preferences: preferences,
      isAnonymous: isAnonymous,
      deletedAt: deletedAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  static Map<String, dynamic> update({
    String? id,
    String? email,
    String? passwordHash,
    String? firstName,
    String? lastName,
    USER_ROLE? role,
    String? contactEmail,
    String? contactPhone,
    Map<String, dynamic>? preferences,
    bool? isAnonymous,
    DateTime? deletedAt,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) {
    return _generateMap(
      id: id,
      email: email,
      passwordHash: passwordHash,
      firstName: firstName,
      lastName: lastName,
      role: role,
      contactEmail: contactEmail,
      contactPhone: contactPhone,
      preferences: preferences,
      isAnonymous: isAnonymous,
      deletedAt: deletedAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }

  factory Users.fromJson(Map<String, dynamic> jsonn) {
    return Users(
      id: jsonn['id'] != null ? jsonn['id'].toString() : '',
      email: jsonn['email'] != null ? jsonn['email'].toString() : '',
      passwordHash: jsonn['password_hash'] != null
          ? jsonn['password_hash'].toString()
          : '',
      firstName: jsonn['first_name'] != null
          ? jsonn['first_name'].toString()
          : '',
      lastName: jsonn['last_name'] != null
          ? jsonn['last_name'].toString()
          : null,
      role: jsonn['role'] != null
          ? USER_ROLE.values.byName(jsonn['role'].toString())
          : USER_ROLE.values.first,
      contactEmail: jsonn['contact_email'] != null
          ? jsonn['contact_email'].toString()
          : null,
      contactPhone: jsonn['contact_phone'] != null
          ? jsonn['contact_phone'].toString()
          : null,
      preferences: jsonn['preferences'] != null
          ? jsonn['preferences'] as Map<String, dynamic>
          : <String, dynamic>{},
      isAnonymous: jsonn['is_anonymous'] != null
          ? jsonn['is_anonymous'] as bool
          : false,
      deletedAt: jsonn['deleted_at'] != null
          ? DateTime.parse(jsonn['deleted_at'].toString())
          : null,
      createdAt: jsonn['created_at'] != null
          ? DateTime.parse(jsonn['created_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
      updatedAt: jsonn['updated_at'] != null
          ? DateTime.parse(jsonn['updated_at'].toString())
          : DateTime.fromMillisecondsSinceEpoch(0),
    );
  }

  Map<String, dynamic> toJson() {
    return _generateMap(
      id: id,
      email: email,
      passwordHash: passwordHash,
      firstName: firstName,
      lastName: lastName,
      role: role,
      contactEmail: contactEmail,
      contactPhone: contactPhone,
      preferences: preferences,
      isAnonymous: isAnonymous,
      deletedAt: deletedAt,
      createdAt: createdAt,
      updatedAt: updatedAt,
    );
  }
}
